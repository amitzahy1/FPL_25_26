<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPL Ultimate Draft Tool</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh; padding: 15px; line-height: 1.4; max-width: 1600px; margin: 0 auto; /* Increased max-width */
        }
        .header { text-align: center; margin-bottom: 20px; background: white; padding: 15px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.1); }
        h1 { color: #2c3e50; font-size: 1.8em; margin-bottom: 8px; font-weight: 700; }
        .subtitle { color: #7f8c8d; font-size: 1em; font-weight: 500; }
        .legend {
            background: #fff; padding: 12px; border-radius: 8px; text-align: center;
            margin-bottom: 20px; font-size: 0.9em; box-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }
        .legend-item { display: inline-block; margin: 0 10px; }
        .legend-title { font-weight: 600; cursor: help; border-bottom: 1px dotted #2c3e50; }
        .filters { background: white; padding: 15px; margin-bottom: 15px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,0.1); display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; align-items: end; }
        .filter-group { display: flex; flex-direction: column; }
        label { font-weight: 600; margin-bottom: 4px; color: #2c3e50; font-size: 0.85em; }
        select, input { padding: 8px; border: 2px solid #ecf0f1; border-radius: 6px; font-size: 12px; transition: all 0.3s ease; }
        select:focus, input:focus { outline: none; border-color: #a1c4fd; box-shadow: 0 0 0 3px rgba(161, 196, 253, 0.2); }
        .controls { display: flex; gap: 10px; margin-bottom: 15px; justify-content: center; flex-wrap: wrap; }
        .control-button {
            background: linear-gradient(135deg, #e2e8f0 0%, #f1f5f9 100%); color: #475569;
            border: 1px solid #cbd5e1; padding: 8px 16px; border-radius: 8px; cursor: pointer;
            font-weight: 600; transition: all 0.3s ease; font-size: 0.85em;
        }
        .control-button:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.1); background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%); }
        .control-button.active { background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%); color: #333; border-color: #a1c4fd; }
        .table-container { background: white; border-radius: 12px; overflow: hidden; box-shadow: 0 6px 20px rgba(0,0,0,0.1); overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; font-size: 0.85em; } /* Font size updated */
        th { background: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%); color: #333; padding: 10px 6px; text-align: center; font-weight: 600; white-space: nowrap; cursor: pointer; user-select: none; transition: all 0.3s ease; position: sticky; top: 0; z-index: 10; }
        th:hover { background: linear-gradient(135deg, #8ab2f2 0%, #a1c4fd 100%); }
        th.sorted { background: linear-gradient(135deg, #8ab2f2 0%, #a1c4fd 100%); }
        td { padding: 8px 6px; border-bottom: 1px solid #f8f9fa; white-space: nowrap; text-align: center; } /* Bold removed */
        tr:hover { background: #f1f5f9; }
        .name-cell { color: #2c3e50; min-width: 100px; text-align:right; }
        .player-name-icon { margin-right: 5px; font-size: 0.9em; }
        .verbal-insights-cell { white-space: normal; font-size: 0.9em; line-height: 1.2; color: #5a6c7d; min-width: 150px; text-align: right;}
        .position-gkp { background-color: #fff3cd !important; }
        .position-def { background-color: #d1ecf1 !important; }
        .position-mid { background-color: #d4edda !important; }
        .position-fwd { background-color: #e9ecef !important; } /* Changed to light grey */
        .xdiff-positive { color: #27ae60; font-weight: 600; }
        .xdiff-negative { color: #e74c3c; font-weight: 600; }
        .sort-indicator { display: inline-block; margin-left: 3px; }
        .bold-cell { font-weight: 700; } /* Class for bolding specific cells */
        .set-piece-yes { color: #27ae60; font-weight: 700; font-size: 1.2em; }
        .set-piece-no { color: #e74c3c; font-weight: 700; font-size: 1.1em; }
        .news-cell { font-size: 0.8em; } /* Smaller font for news */
        .insights-cell { font-size: 0.95em; line-height: 1.3; } /* Larger font for insights */
        .player-injured { color: #e74c3c; font-weight: 600; }
        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(4px);
        }
        .modal-content {
            background-color: #f8f9fa; margin: 5% auto; padding: 25px; border: none;
            width: 90%; max-width: 1200px; border-radius: 16px; box-shadow: 0 8px 30px rgba(0,0,0,0.15);
        }
        .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.2s; }
        .close:hover { color: #333; }
        #compareModal h2 { text-align: center; margin-bottom: 20px; color: #343a40; }
        #compareTable { 
            width: 100%; 
            border-collapse: separate; 
            border-spacing: 0 8px;
            margin-top: 15px;
        }
        #compareTable th { 
            background: #e9ecef;
            color: #495057;
            padding: 12px 15px;
            font-size: 1em;
            text-align: center;
            border: none;
        }
        #compareTable th:first-child { text-align: right; border-top-left-radius: 8px; border-bottom-left-radius: 8px;}
        #compareTable th:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px;}
        #compareTable td {
            background: #fff;
            padding: 12px 15px;
            text-align: center;
            font-size: 1.1em;
            border: none;
            border-bottom: 1px solid #f1f3f5;
        }
        #compareTable tr td:first-child { font-weight: 600; color: #495057; text-align: right; border-top-left-radius: 8px; border-bottom-left-radius: 8px;}
        #compareTable tr td:last-child { border-top-right-radius: 8px; border-bottom-right-radius: 8px;}
        .value-best { background-color: #d1f7c4 !important; font-weight: 700; color: #1a5c0a; }
        .value-good { background-color: #e8f9e4 !important; }
        .value-mid { background-color: #fff9db !important; }
        .value-bad { background-color: #ffe8e8 !important; }
        .value-worst { background-color: #ffd6d6 !important; font-weight: normal; color: #8a2a2a;}
        .emoji-legend { background: white; padding: 15px; margin-bottom: 15px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); }
        .emoji-legend-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; text-align: right; font-size: 0.85em;}
        .insights-list { list-style-type: none; padding-right: 0; margin-right: 0; text-align: right; }
        .insights-list li { margin-bottom: 3px; }
    </style>
</head>
<body>
    <div class="container">
    <div class="header">
            <h1>🏆 FPL Ultimate Draft Tool</h1>
            <p class="subtitle">ניתוח חכם | ציון דראפט ייעודי | סינון מתקדם</p>
            <p id="lastUpdated" class="subtitle" style="font-size: 0.8em; margin-top: 5px;"></p>
        </div>
        <div class="legend">
            <p>
                <span class="legend-item"><strong class="legend-title" title="ציון ייעודי המחושב לפי עמדה להערכת שווי בדראפט. מבוסס על מדדים כמו xG, xA, ICT, BPS, שערים נקיים ועוד, עם משקולות שונות לכל עמדה.">ציון דראפט</strong></span>
                <span class="legend-item"><strong class="legend-title" title="ההפרש בין שערים ובישולים בפועל (G+A) לביצוע הצפוי (xG+xA). ערך חיובי (ירוק) = ביצועי יתר (מעל המצופה). ערך שלילי (אדום) = ביצועי חסר (מתחת למצופה).">xDiff</strong></span>
                <span class="legend-item"><strong class="legend-title" title="מדד השפעה, יצירתיות ואיום">ICT</strong></span>
            </p>
    </div>
    <div class="filters">
            <div class="filter-group"><label>🔍 חיפוש שחקן:</label><input type="text" id="searchName" onkeyup="processChange()" placeholder="שם שחקן..."></div>
            <div class="filter-group"><label>⚽ עמדה:</label><select id="positionFilter" onchange="processChange()"><option value="">כל העמדות</option><option value="GKP">🥅 שוערים</option><option value="DEF">🛡️ מגנים</option><option value="MID">⚽ קשרים</option><option value="FWD">🎯 חלוצים</option></select></div>
            <div class="filter-group"><label>🏟️ קבוצה:</label><select id="teamFilter" onchange="processChange()"><option value="">כל הקבוצות</option></select></div>
            <div class="filter-group"><label>💰 מחיר טווח:</label><input type="text" id="priceRange" onkeyup="processChange()" placeholder="4.0-15.0"></div>
            <div class="filter-group"><label>🏆 נקודות מינימום:</label><input type="number" id="minPoints" onkeyup="processChange()" placeholder="0"></div>
            <div class="filter-group"><label>🎯 טווח xDiff:</label><select id="xDiffFilter" onchange="processChange()"><option value="">כל הטווח</option><option value="positive">חיובי (ביצועי יתר)</option><option value="negative">שלילי (ביצועי חסר)</option></select></div>
            <div class="filter-group"><label>הצג:</label><select id="showEntries" onchange="processChange()"><option value="50">50</option><option value="100">100</option><option value="200">200</option><option value="all" selected>הכל</option></select></div>
        </div>
    <div class="controls">
        <button class="control-button active" onclick="showAllPlayers(this)">כל השחקנים</button>
        <button class="control-button" id="compareBtn" onclick="compareSelectedPlayers()">השווה שחקנים נבחרים</button>
        <button class="control-button" data-filter-name="set_pieces" onclick="quickFilter(this, 'set_pieces')" title="מציג שחקנים שלוקחים פנדלים, קרנות או בעיטות חופשיות, על בסיס הנתונים שזוהו. ממוין לפי ציון דראפט.">🎯 בועטי מצבים נייחים</button>
        <button class="control-button" data-filter-name="attacking_defenders" onclick="quickFilter(this, 'attacking_defenders')" title="מציג שחקני הגנה עם נתוני xGI/90 גבוהים, ששיחקו מעל 300 דקות. המיון הוא לפי ציון דראפט.">🛡️ מגנים תוקפים</button>
        <button class="control-button" data-filter-name="high_ownership" onclick="quickFilter(this, 'high_ownership')" title="מציג שחקנים עם אחוז החזקה מעל 10%. ממוין לפי אחוז החזקה.">📈 שחקנים פופולריים</button>
        <button class="control-button" data-filter-name="overperformers" onclick="quickFilter(this, 'overperformers')" title="מציג שחקנים ששיחקו מעל 300 דקות וה-xDiff שלהם גבוה מ-2.5. המיון הוא לפי ציון דראפט.">📈 ביצועי יתר</button>
        <button class="control-button" data-filter-name="differentials" onclick="quickFilter(this, 'differentials')" title="מציג שחקנים עם אחוז החזקה נמוך מ-5%. המיון הוא לפי ציון דראפט.">💎 מציאות (עד 5%)</button>
        <button class="control-button" data-filter-name="newcomers" onclick="quickFilter(this, 'newcomers')" title="מציג שחקנים ללא דקות משחק בעונה שעברה. המיון הוא לפי ציון 'הייפ' המבוסס על מחיר ואחוז החזקה.">🌟 שחקנים חדשים</button>
        <button class="control-button" onclick="exportToCsv()">📁 יצוא CSV</button>
        <div class="season-controls" style="margin-top: 10px; display: flex; justify-content: center; width: 100%;">
            <button class="control-button active" id="historicalDataBtn" onclick="switchDataSource('historical')">נתוני עבר (2024/25)</button>
            <button class="control-button" id="liveDataBtn" onclick="switchDataSource('live')">נתונים חיים (2025/26)</button>
        </div>
    </div>

    <div class="emoji-legend">
        <strong>מקרא אייקונים:</strong>
        <div class="emoji-legend-grid">
            <div><span>🎯</span> - בועט פנדלים</div>
            <div><span>⚽</span> - לוקח קרנות</div>
            <div><span>👟</span> - בועט חופשיות</div>
            <div><span>💎</span> - דיפרנציאל (&lt;5% החזקה)</div>
            <div><span>💰</span> - תמורה למחיר (Value)</div>
            <div><span>🌟</span> - שחקן חדש/ללא דקות</div>
            <div><span>📉</span> - ביצועי חסר (xDiff שלילי)</div>
            <div><span>📈</span> - ביצועי יתר (xDiff חיובי)</div>
        </div>
    </div>
    
    <div class="table-container">
        <table id="playersTable">
            <thead>
                <tr>
                    <th onclick="sortTable(0)">דירוג<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(1)">שחקן<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(2)">ציון דראפט<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(3)">קבוצה<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(4)">עמדה<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(5)">מחיר<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(6)">נקודות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(7)">נק'/משחק<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(8)">% בחירה<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(9)">שער+בישול<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(10)">xG+xA<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(11)">דקות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(12)">xDiff<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(13)">ICT<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(14)">בונוס<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(15)">רשת נקייה<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(16)">פנדלים<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(17)">קרנות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(18)">חופשיות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(19)">תובנות<span class="sort-indicator"></span></th>
                    <th onclick="sortTable(20)">חדשות<span class="sort-indicator"></span></th>
                    <th>בחר</th>
                </tr>
            </thead>
            <tbody id="playersTableBody"></tbody>
        </table>
    </div>

    <div id="compareModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h2>השוואת שחקנים</h2>
            <div class="table-container">
                <table id="compareTable"></table>
            </div>
        </div>
    </div>

    </div>
    <script>
        let allPlayersData = {
            historical: null,
            live: null
        };
        let currentDataSource = 'historical';
        let teamsData = {};
        let displayedData = [];
        let sortColumn = 2; // Default sort by Draft Score
        let sortDirection = 'desc';
        let activeQuickFilterName = null;
        let selectedForComparison = new Set();
        
        document.addEventListener('DOMContentLoaded', () => {
            fetchAndProcessData();
            setupEventListeners();
        });

        async function fetchAndProcessData() {
            try {
                // If we haven't loaded the historical data yet
                if (!allPlayersData.historical) {
                    try {
                        const historicalResponse = await fetch('FPL_Bootstrap_static.json');
                        if (!historicalResponse.ok) throw new Error(`Failed to fetch historical data: ${historicalResponse.statusText}`);
                        const historicalData = await historicalResponse.json();
                        allPlayersData.historical = historicalData;
                    } catch (error) {
                        console.error("Error fetching historical data:", error);
                        // If historical data fails and we're trying to use it, show error
                        if (currentDataSource === 'historical') {
                            document.getElementById('playersTableBody').innerHTML = '<tr><td colspan="20">שגיאה בטעינת נתוני עבר. אנא נסה שוב מאוחר יותר.</td></tr>';
                            return;
                        }
                    }
                }
                
                // If we haven't loaded the live data yet and we're trying to use it
                if (!allPlayersData.live && currentDataSource === 'live') {
                    try {
                        const liveResponse = await fetch('https://corsproxy.io/?' + encodeURIComponent('https://fantasy.premierleague.com/api/bootstrap-static/'));
                        if (!liveResponse.ok) throw new Error(`Failed to fetch live data: ${liveResponse.statusText}`);
                        const liveData = await liveResponse.json();
                        allPlayersData.live = liveData;
                    } catch (error) {
                        console.error("Error fetching live data:", error);
                        // If live data fails, fall back to historical
                        if (currentDataSource === 'live') {
                            if (allPlayersData.historical) {
                                currentDataSource = 'historical';
                                document.getElementById('historicalDataBtn').classList.add('active');
                                document.getElementById('liveDataBtn').classList.remove('active');
                                alert('לא ניתן לטעון נתונים חיים כרגע. מציג נתוני עבר.');
                            } else {
                                document.getElementById('playersTableBody').innerHTML = '<tr><td colspan="20">שגיאה בטעינת נתונים. אנא נסה שוב מאוחר יותר.</td></tr>';
                                return;
                            }
                        }
                    }
                }

                // Use the appropriate data source
                const data = allPlayersData[currentDataSource];
                if (!data) {
                    throw new Error(`No data available for ${currentDataSource} source`);
                }

                // Update the last updated timestamp
                const now = new Date();
                const formattedDate = `עדכון אחרון: ${now.toLocaleDateString('he-IL')} ${now.toLocaleTimeString('he-IL')}`;
                document.getElementById('lastUpdated').textContent = formattedDate;

                const setPieceTakers = getHardcodedSetPieceTakers();
                
                teamsData = data.teams.reduce((acc, team) => {
                    acc[team.id] = team.name;
                    return acc;
                }, {});
                const teamNameToId = {};
                data.teams.forEach(team => { teamNameToId[team.name] = team.id; });

                const availablePlayers = data.elements.filter(p => p.status !== 'u');

                const existingPlayerNames = new Set(availablePlayers.map(p => p.web_name.toLowerCase()));
                const newPlayers = [];

                const teamNameMapping = {
                    "Leeds": "Leeds United", "Man City": "Manchester City", "Man Utd": "Manchester United",
                    "Newcastle": "Newcastle United", "Nott'm Forest": "Nottingham Forest", "Spurs": "Tottenham Hotspur",
                    "West Ham": "West Ham United", "Wolves": "Wolverhampton Wanderers"
                };

                for (const teamName in setPieceTakers) {
                    const fplTeamName = teamNameMapping[teamName] || teamName;
                    const teamId = teamNameToId[fplTeamName];
                    if (!teamId) {
                        console.warn(`Could not find a team ID for: ${teamName}`);
                        continue;
                    }

                    const takers = setPieceTakers[teamName];
                    const allTakersInTeam = [...new Set([...takers.penalties, ...takers.corners, ...takers.freekicks])];

                    for (const takerName of allTakersInTeam) {
                        if (!takerName || existingPlayerNames.has(takerName.toLowerCase())) {
                            continue;
                        }

                        const rawNewPlayer = {
                            id: 9000 + newPlayers.length, web_name: takerName, first_name: takerName.split(' ')[0],
                            second_name: takerName.split(' ').slice(1).join(' ') || takerName.split(' ')[0],
                            team: teamId, element_type: 3, now_cost: 75, total_points: 0, points_per_game: '0.0',
                            form: '0.0', minutes: 0, goals_scored: 0, assists: 0, clean_sheets: 0, goals_conceded: 0,
                            own_goals: 0, penalties_saved: 0, penalties_missed: 0, yellow_cards: 0, red_cards: 0,
                            saves: 0, bonus: 0, bps: 0, influence: '0.0', creativity: '0.0', threat: '0.0',
                            ict_index: '0.0', starts: 0, expected_goals: '0.00', expected_assists: '0.00',
                            expected_goal_involvements: '0.00', expected_goals_conceded: '0.00',
                            selected_by_percent: '1.0', news: 'שחקן חדש (סימולציה)', chance_of_playing_next_round: 100
                        };
                        newPlayers.push(rawNewPlayer);
                        existingPlayerNames.add(takerName.toLowerCase());
                    }
                }

                const combinedPlayers = [...availablePlayers, ...newPlayers];
                const processedData = preprocessPlayerData(combinedPlayers, setPieceTakers);
                
                // Store the processed data in the appropriate source
                if (currentDataSource === 'historical') {
                    allPlayersData.historical.processedPlayers = processedData;
                } else {
                    allPlayersData.live.processedPlayers = processedData;
                }
                
                populateTeamFilter();
                processChange(); // Initial render with default sort
            } catch (error) {
                console.error('Error fetching or processing data:', error);
                document.getElementById('playersTableBody').innerHTML = `<tr><td colspan="20">שגיאה בטעינת נתונים: ${error.message}</td></tr>`;
            }
        }
        
        function switchDataSource(source) {
            if (source === currentDataSource) return;
            
            currentDataSource = source;
            
            // Update button states
            document.getElementById('historicalDataBtn').classList.toggle('active', source === 'historical');
            document.getElementById('liveDataBtn').classList.toggle('active', source === 'live');
            
            // If we already have the data processed, just update the display
            if (allPlayersData[source] && allPlayersData[source].processedPlayers) {
                // Update the last updated timestamp
                const now = new Date();
                const formattedDate = `עדכון אחרון: ${now.toLocaleDateString('he-IL')} ${now.toLocaleTimeString('he-IL')}`;
                document.getElementById('lastUpdated').textContent = formattedDate;
                
                populateTeamFilter();
                processChange();
            } else {
                // Otherwise, fetch and process the data
                fetchAndProcessData();
            }
        }
        
        function getHardcodedSetPieceTakers() {
            // Data parsed from the latest SetPieceTakerSS.csv and mapped to exact FPL web_names
            // NOTE: Only first penalty taker is used. First 2 for others.
            return {
                "Arsenal": { "penalties": ["Saka"], "freekicks": ["Ødegaard", "Rice"], "corners": ["Rice", "Saka"] },
                "Aston Villa": { "penalties": ["Watkins"], "freekicks": ["Digne", "Bailey"], "corners": ["Tielemans", "Digne"] },
                "Bournemouth": { "penalties": ["Kluivert"], "freekicks": ["Tavernier", "Kluivert"], "corners": ["Tavernier", "Kluivert"] },
                "Brentford": { "penalties": ["Wissa"], "freekicks": ["Damsgaard", "Lewis-Potter"], "corners": ["Damsgaard", "Jensen"] },
                "Brighton": { "penalties": ["Welbeck"], "freekicks": ["Welbeck", "O'Riley"], "corners": ["Ayari", "O'Riley"] },
                "Burnley": { "penalties": ["Brownhill"], "freekicks": ["Anthony", "Brownhill"], "corners": ["Anthony", "Gudmundsson"] },
                "Chelsea": { "penalties": ["Palmer"], "freekicks": ["Palmer", "James"], "corners": ["Gallagher", "Chilwell"] },
                "Crystal Palace": { "penalties": ["Eze"], "freekicks": ["Eze", "Olise"], "corners": ["Eze", "Hughes"] },
                "Everton": { "penalties": ["McNeil"], "freekicks": ["Garner"], "corners": ["McNeil", "Garner"] },
                "Fulham": { "penalties": ["Jiménez"], "freekicks": ["Andreas", "Jiménez"], "corners": ["Andreas", "Lukic"] },
                "Leeds": { "penalties": ["Struijk"], "freekicks": ["Gruev", "Aaronson"], "corners": ["James", "Gruev"] },
                "Liverpool": { "penalties": ["M.Salah"], "freekicks": ["Szoboszlai", "Mac Allister"], "corners": ["Mac Allister", "Wirtz"] },
                "Man City": { "penalties": ["Haaland"], "freekicks": ["De Bruyne", "Foden"], "corners": ["Foden", "De Bruyne"] },
                "Man Utd": { "penalties": ["B.Fernandes"], "freekicks": ["B.Fernandes", "Cunha"], "corners": ["B.Fernandes", "Mbeumo"] },
                "Newcastle": { "penalties": ["Isak"], "freekicks": ["Trippier", "Schär"], "corners": ["Trippier", "Elanga"] }, 
                "Nott'm Forest": { "penalties": ["Wood"], "freekicks": ["Gibbs-White", "Murillo"], "corners": ["Anderson", "Gibbs-White"] },
                "Sunderland": { "penalties": ["Rigg"], "freekicks": ["Roberts", "Pritchard"], "corners": ["Roberts", "Pritchard"] },
                "Spurs": { "penalties": ["Solanke"], "freekicks": ["Pedro Porro", "Maddison"], "corners": ["Maddison", "Pedro Porro"] },
                "West Ham": { "penalties": ["L.Paquetá"], "freekicks": ["Ward-Prowse", "L.Paquetá"], "corners": ["Bowen", "Ward-Prowse"] },
                "Wolves": { "penalties": ["Strand Larsen"], "freekicks": ["J.Arias", "Sarabia"], "corners": ["Bellegarde", "Nouri"] }
            };
        }

        function getPositionName(elementTypeId) {
            switch (elementTypeId) {
                case 1: return 'GKP';
                case 2: return 'DEF';
                case 3: return 'MID';
                case 4: return 'FWD';
                default: return 'Unknown';
            }
        }
        
        function preprocessPlayerData(players, setPieceTakers) {
            const positions = { 1: [], 2: [], 3: [], 4: [] };
            
            // Create a flat list of main penalty takers for a direct and reliable check
            const mainPenaltyTakers = Object.values(setPieceTakers)
                .map(takers => takers.penalties[0]) // Get the first penalty taker from each team's list
                .filter(name => name) // Filter out any undefined/empty names
                .map(name => name.toLowerCase()); // Convert all to lower case for matching
            
            players.forEach(p => {
                if (p.element_type in positions) {
                    positions[p.element_type].push(p.now_cost / 10);
                }
            });

            const priceTiers = {};
            for (const posId in positions) {
                const prices = positions[posId].sort((a, b) => a - b);
                priceTiers[posId] = {
                    p95: getPercentile(prices, 95),
                    p80: getPercentile(prices, 80),
                    p50: getPercentile(prices, 50)
                };
            }

            return players.map(p => {
                const minutes = parseInt(p.minutes || 0, 10); // Ensure minutes is an integer
                const gi = (p.goals_scored || 0) + (p.assists || 0);
                const xgi = parseFloat(p.expected_goal_involvements) || 0;

                p.xG_per90 = minutes > 0 ? (parseFloat(p.expected_goals) / minutes) * 90 : 0;
                p.xA_per90 = minutes > 0 ? (parseFloat(p.expected_assists) / minutes) * 90 : 0;
                p.xGI_per90 = minutes > 0 ? (parseFloat(p.expected_goal_involvements) / minutes) * 90 : 0;
                p.xGC_per90 = minutes > 0 ? (parseFloat(p.expected_goals_conceded) / minutes) * 90 : 0;
                p.ict_per_90 = minutes > 0 ? (parseFloat(p.ict_index) / minutes) * 90 : 0;
                p.clean_sheets_per90 = minutes > 0 ? (p.clean_sheets / minutes) * 90 : 0;
                p.saves_per90 = minutes > 0 ? (p.saves / minutes) * 90 : 0;
                p.bonus_per90 = minutes > 0 ? (p.bonus / minutes) * 90 : 0;


                p.xDiff = gi - xgi;
                p.now_cost = p.now_cost / 10;
                p.team_name = teamsData[p.team];
                p.position_name = getPositionName(p.element_type);
                
                const normalizedPlayerName = p.web_name.toLowerCase();

                // Custom override for Maddison's injury status
                if (p.web_name === 'Maddison') {
                    p.news = 'Injury - Expected back 01 Aug';
                }

                // --- NEW, MORE RELIABLE LOGIC ---
                // 1. Check against the simple, flat list of main penalty takers
                p.takes_penalties = mainPenaltyTakers.includes(normalizedPlayerName);
                
                // 2. For corners and free kicks, check if the player is listed for ANY team (to handle transfers)
                p.takes_corners = false;
                p.takes_free_kicks = false;
                for (const teamName in setPieceTakers) {
                    const takers = setPieceTakers[teamName];
                    if (takers.corners.some(name => normalizedPlayerName === name.toLowerCase())) {
                        p.takes_corners = true;
                    }
                    if (takers.freekicks.some(name => normalizedPlayerName === name.toLowerCase())) {
                        p.takes_free_kicks = true;
                    }
                }
                
                const tiers = priceTiers[p.element_type];
                if (p.now_cost >= tiers.p95) p.price_tier = 'Elite';
                else if (p.now_cost >= tiers.p80) p.price_tier = 'Premium';
                else if (p.now_cost >= tiers.p50) p.price_tier = 'Mid-range';
                else p.price_tier = 'Budget';

                // Points Per Game
                p.points_per_game = p.minutes > 0 ? ((p.total_points / p.minutes) * 90).toFixed(2) : '0.00';

                // DRAFT SCORE LOGIC
                let draft_score = 0;
                if (minutes === 0) { // Newcomer: Hype Score
                    draft_score = (p.now_cost * 4) + (parseFloat(p.selected_by_percent) * 1.5);
                
                // Player with limited data (1-899 minutes) - use conservative score
                } else if (minutes > 0 && minutes < 900) { 
                    draft_score = p.total_points * 1.5;

                // Established players (900+ minutes) - use the new detailed formulas
                } else {
                    let position_score = 0;
                    switch(p.position_name) {
                        case 'FWD':
                            position_score = (parseFloat(p.points_per_game) * 10) +
                                           (p.xGI_per90 * 18) + // Increased from 15
                                           (p.ict_per_90 * 3);
                            if (p.takes_penalties) position_score += 10;
                            break;
                        case 'MID':
                            position_score = (parseFloat(p.points_per_game) * 12) +
                                           (p.xGI_per90 * 17) + // Increased from 14
                                           (p.ict_per_90 * 5);
                            if (p.takes_penalties) position_score += 10;
                            if (p.takes_corners) position_score += 4;
                            if (p.takes_free_kicks) position_score += 2;
                            break;
                        case 'DEF':
                            position_score = (parseFloat(p.points_per_game) * 15) +
                                           (p.clean_sheets_per90 * 8) +
                                           (p.xGI_per90 * 12) + // Increased from 10
                                           (p.ict_per_90 * 4) -
                                           (p.xGC_per90 * 3);
                            break;
                        case 'GKP':
                            position_score = (parseFloat(p.points_per_game) * 10) +
                                           (p.clean_sheets_per90 * 12) +
                                           (p.saves_per90 * 6) +
                                           (p.bonus_per90 * 8) -
                                           (p.xGC_per90 * 4);
                            break;
                    }
                     // Add final universal boosts for total points and price
                    const totalPointsBoost = p.total_points / 15; // e.g., 200 points = +13.3 score
                    const priceBoost = p.now_cost * 3.5; // Increased from 2.5
                    
                    draft_score = position_score + totalPointsBoost + priceBoost + (parseFloat(p.selected_by_percent) / 2);
                }
                p.draft_score = Math.max(0, draft_score); // Ensure no negative scores


                return p;
            });
        }

        function getPercentile(sortedArr, percentile) {
            if (!sortedArr.length) return 0;
            const index = (percentile / 100) * (sortedArr.length - 1);
            const floor = Math.floor(index);
            const ceil = Math.ceil(index);
            if (floor === ceil) return sortedArr[floor];
            const d0 = sortedArr[floor] * (ceil - index);
            const d1 = sortedArr[ceil] * (index - floor);
            return d0 + d1;
        }

        function setupEventListeners() {
            document.getElementById('searchName').addEventListener('keyup', processChange);
            document.getElementById('positionFilter').addEventListener('change', processChange);
            document.getElementById('teamFilter').addEventListener('change', processChange);
            document.getElementById('priceRange').addEventListener('keyup', processChange);
            document.getElementById('minPoints').addEventListener('keyup', processChange);
            document.getElementById('xDiffFilter').addEventListener('change', processChange);
            document.getElementById('showEntries').addEventListener('change', processChange);
        }

        function populateTeamFilter() {
            const teamFilter = document.getElementById('teamFilter');
            teamFilter.innerHTML = '<option value="">כל הקבוצות</option>';
            
            if (!allPlayersData[currentDataSource] || !allPlayersData[currentDataSource].processedPlayers) return;
            
            const uniqueTeams = [...new Set(allPlayersData[currentDataSource].processedPlayers.map(p => p.team_name))].sort();
            uniqueTeams.forEach(team => {
                const option = document.createElement('option');
                option.value = team;
                option.textContent = team;
                teamFilter.appendChild(option);
            });
        }

        function renderTable() {
            // Define the mapping between column indices and player properties
            const columnMapping = [
                'rank',                      // 0
                'web_name',                  // 1
                'draft_score',               // 2
                'team_name',                 // 3
                'position_name',             // 4
                'now_cost',                  // 5
                'total_points',              // 6
                'points_per_game',           // 7
                'selected_by_percent',       // 8
                'goals_scored_assists',      // 9 (calculated)
                'expected_goals_assists',    // 10 (calculated)
                'minutes',                   // 11
                'xDiff',                     // 12
                'ict_index',                 // 13
                'bonus',                     // 14
                'clean_sheets',              // 15
                'takes_penalties',           // 16
                'takes_corners',             // 17
                'takes_free_kicks',          // 18
                'news'                       // 19
            ];
            
            // Sort the data based on the selected column and direction
            displayedData.sort((a, b) => {
                let aValue, bValue;
                
                // Handle special calculated columns
                if (sortColumn === 9) { // G+A
                    aValue = (a.goals_scored || 0) + (a.assists || 0);
                    bValue = (b.goals_scored || 0) + (b.assists || 0);
                } else if (sortColumn === 10) { // xG+xA
                    aValue = parseFloat(a.expected_goals || 0) + parseFloat(a.expected_assists || 0);
                    bValue = parseFloat(b.expected_goals || 0) + parseFloat(b.expected_assists || 0);
                } else {
                    // Regular columns
                    const field = columnMapping[sortColumn];
                    aValue = a[field];
                    bValue = b[field];
                    
                    // Convert string numbers to actual numbers for proper sorting
                    if (typeof aValue === 'string' && !isNaN(aValue)) {
                        aValue = parseFloat(aValue);
                    }
                    if (typeof bValue === 'string' && !isNaN(bValue)) {
                        bValue = parseFloat(bValue);
                    }
                }
                
                // Handle null/undefined values
                if (aValue === null || aValue === undefined) aValue = '';
                if (bValue === null || bValue === undefined) bValue = '';
                
                // Sort based on direction
                if (typeof aValue === 'number' && typeof bValue === 'number') {
                    return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
                } else {
                    const aStr = String(aValue);
                    const bStr = String(bValue);
                    return sortDirection === 'asc' ? aStr.localeCompare(bStr) : bStr.localeCompare(aStr);
                }
            });
            
            const tbody = document.getElementById('playersTableBody');
            tbody.innerHTML = '';
            
            displayedData.forEach((player, index) => {
                const row = document.createElement('tr');
                row.className = `position-${player.position_name.toLowerCase()}`;
                
                // Add injury class to player name if injured
                const injuredClass = player.news ? 'player-injured' : '';
                
                const icons = generatePlayerIcons(player);
                
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td class="name-cell ${injuredClass}"><span class="player-name-icon">${icons}</span>${player.web_name}</td>
                    <td class="bold-cell">${player.draft_score.toFixed(1)}</td>
                    <td>${player.team_name}</td>
                    <td>${player.position_name}</td>
                    <td>${(player.now_cost / 10).toFixed(1)}</td>
                    <td class="bold-cell">${player.total_points}</td>
                    <td>${player.points_per_game}</td>
                    <td>${player.selected_by_percent}%</td>
                    <td>${(player.goals_scored || 0) + (player.assists || 0)}</td>
                    <td>${(parseFloat(player.expected_goals || 0) + parseFloat(player.expected_assists || 0)).toFixed(2)}</td>
                    <td>${player.minutes}</td>
                    <td class="${player.xDiff > 0 ? 'xdiff-positive' : player.xDiff < 0 ? 'xdiff-negative' : ''}">${player.xDiff.toFixed(2)}</td>
                    <td>${player.ict_index}</td>
                    <td>${player.bonus}</td>
                    <td>${player.clean_sheets}</td>
                    <td class="${player.takes_penalties ? 'set-piece-yes' : 'set-piece-no'}">${player.takes_penalties ? '✔' : '❌'}</td>
                    <td class="${player.takes_corners ? 'set-piece-yes' : 'set-piece-no'}">${player.takes_corners ? '✔' : '❌'}</td>
                    <td class="${player.takes_free_kicks ? 'set-piece-yes' : 'set-piece-no'}">${player.takes_free_kicks ? '✔' : '❌'}</td>
                    <td class="verbal-insights-cell">${generateVerbalInsights(player)}</td>
                    <td class="news-cell">${player.news || ''}</td>
                    <td><input type="checkbox" class="player-select" data-player-id="${player.id}" ${selectedForComparison.has(player.id) ? 'checked' : ''}></td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Add event listeners to checkboxes
            document.querySelectorAll('.player-select').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const playerId = parseInt(this.dataset.playerId);
                    if (this.checked) {
                        selectedForComparison.add(playerId);
                    } else {
                        selectedForComparison.delete(playerId);
                    }
                });
            });
        }

        function generatePlayerIcons(p) {
            const icons = [];
            if (p.takes_penalties) icons.push(`<span class='player-name-icon'>🎯</span>`);
            if (p.takes_corners) icons.push(`<span class='player-name-icon'>⚽</span>`);
            if (p.takes_free_kicks) icons.push(`<span class='player-name-icon'>👟</span>`);
            if (parseFloat(p.selected_by_percent) < 5) icons.push(`<span class='player-name-icon'>💎</span>`);
            if (p.price_tier === 'Budget' && p.points_per_game > 3.5) icons.push(`<span class='player-name-icon'>💰</span>`);
            if (p.minutes === 0) icons.push(`<span class='player-name-icon'>🌟</span>`);
            return icons.join("");
        }
        
        function generateVerbalInsights(p) {
            const insights = [];
            if (p.takes_penalties) insights.push("<li>בועט פנדלים</li>");
            if (p.takes_corners) insights.push("<li>לוקח קרנות</li>");
            if (p.takes_free_kicks) insights.push("<li>בועט חופשיות</li>");
            if (parseFloat(p.selected_by_percent) < 5 && p.minutes > 0) insights.push(`<li>דיפרנציאל (${p.selected_by_percent}%)</li>`);
            if (p.price_tier === 'Budget' && p.points_per_game > 3.5) insights.push("<li>תמורה למחיר (Value)</li>");
            if (p.minutes === 0) insights.push("<li>שחקן חדש/ללא דקות</li>");
            if (p.xDiff < -0.5) insights.push(`<li>ביצועי חסר (xDiff: ${p.xDiff.toFixed(2)})</li>`);
            if (p.xDiff > 0.5) insights.push(`<li>ביצועי יתר (xDiff: ${p.xDiff.toFixed(2)})</li>`);
            
            if (insights.length > 0) {
                return `<ul class="insights-list">${insights.join('')}</ul>`;
            }
            return '';
        }
        
        function processChange() {
            const data = allPlayersData[currentDataSource];
            if (!data || !data.processedPlayers) {
                return;
            }
            
            // Get all the current filter values
            const nameFilter = document.getElementById('searchName').value.toLowerCase();
            const positionFilter = document.getElementById('positionFilter').value;
            const teamFilter = document.getElementById('teamFilter').value;
            const priceRangeInput = document.getElementById('priceRange').value;
            const minPointsInput = document.getElementById('minPoints').value;
            const xDiffFilter = document.getElementById('xDiffFilter').value;
            const showEntries = document.getElementById('showEntries').value;
            
            // Parse price range
            let minPrice = 0, maxPrice = 20;
            if (priceRangeInput) {
                const parts = priceRangeInput.split('-');
                if (parts.length === 2) {
                    minPrice = parseFloat(parts[0]) || 0;
                    maxPrice = parseFloat(parts[1]) || 20;
                } else {
                    const singlePrice = parseFloat(priceRangeInput);
                    if (!isNaN(singlePrice)) {
                        minPrice = maxPrice = singlePrice;
                    }
                }
            }
            
            const minPoints = parseInt(minPointsInput) || 0;
            
            // Apply filters
            displayedData = data.processedPlayers.filter(p => {
                if (nameFilter && !p.web_name.toLowerCase().includes(nameFilter)) return false;
                if (positionFilter && p.position_name !== positionFilter) return false;
                if (teamFilter && p.team_name !== teamFilter) return false;
                if (p.now_cost < minPrice || p.now_cost > maxPrice) return false;
                if (p.total_points < minPoints) return false;
                if (xDiffFilter === 'positive' && p.xDiff <= 0) return false;
                if (xDiffFilter === 'negative' && p.xDiff >= 0) return false;
                return true;
            });
            
            // Apply any active quick filter
            if (activeQuickFilterName) {
                applyQuickFilter(activeQuickFilterName);
            }
            
            // Limit number of entries if needed
            if (showEntries !== 'all') {
                const limit = parseInt(showEntries);
                displayedData = displayedData.slice(0, limit);
            }
            
            renderTable();
        }
        
        function applyQuickFilter(filterName) {
            const data = allPlayersData[currentDataSource];
            if (!data || !data.processedPlayers) return;

            switch(filterName) {
                case 'set_pieces':
                    displayedData = data.processedPlayers.filter(p => p.takes_penalties || p.takes_corners || p.takes_free_kicks);
                    break;
                case 'attacking_defenders':
                    displayedData = data.processedPlayers.filter(p => p.position_name === 'DEF' && p.minutes > 300);
                    break;
                case 'high_ownership':
                    displayedData = data.processedPlayers.filter(p => parseFloat(p.selected_by_percent) >= 10);
                    break;
                case 'overperformers':
                    displayedData = data.processedPlayers.filter(p => p.minutes > 300 && p.xDiff > 2.5);
                    break;
                case 'differentials':
                    displayedData = data.processedPlayers.filter(p => parseFloat(p.selected_by_percent) < 5);
                    break;
                case 'newcomers':
                    displayedData = data.processedPlayers.filter(p => p.minutes === 0);
                    break;
                default:
                    displayedData = data.processedPlayers; // No filter applied
                    break;
            }
            renderTable();
        }

        function sortAndDisplay(data) {
            const fields = ['rank', 'web_name', 'draft_score', 'team_name', 'position_name', 'now_cost', 'total_points', 'points_per_game', 'selected_by_percent', 'goals_scored', 'expected_goal_involvements', 'minutes', 'xDiff', 'ict_index', 'bonus', 'clean_sheets'];
            const sortField = fields[sortColumn];
            const numericFields = ['draft_score', 'now_cost', 'total_points', 'points_per_game', 'selected_by_percent', 'minutes', 'xDiff', 'ict_index', 'bonus', 'clean_sheets'];

            data.sort((a, b) => {
                let valA = a[sortField];
                let valB = b[sortField];

                if (sortField === 'verbal_insights') {
                    valA = generateVerbalInsights(a);
                    valB = generateVerbalInsights(b);
                } else if (sortField === 'goals_scored') { // Special handling for G+A
                    valA = (a.goals_scored || 0) + (a.assists || 0);
                    valB = (b.goals_scored || 0) + (b.assists || 0);
                }
                
                if (numericFields.includes(sortField)) {
                    valA = parseFloat(valA) || 0;
                    valB = parseFloat(valB) || 0;
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }

                if (typeof valA === 'string') {
                    return sortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(aStr);
                }
                return sortDirection === 'asc' ? (valA || 0) - (valB || 0) : (valB || 0) - (valA || 0);
            });

            displayedData = data;
            renderTable();
        }

        function sortTable(columnIndex, direction) {
            // If no direction is specified, toggle the current direction
            if (!direction) {
                if (sortColumn === columnIndex) {
                    sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    sortColumn = columnIndex;
                    sortDirection = 'desc'; // Default to descending for new column
                }
            } else {
                sortColumn = columnIndex;
                sortDirection = direction;
            }
            
            // Update sort indicators
            document.querySelectorAll('th').forEach((th, i) => {
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) {
                    indicator.textContent = '';
                    if (i === columnIndex) {
                        th.classList.add('sorted');
                        indicator.textContent = sortDirection === 'desc' ? '▼' : '▲'; 
                    } else {
                        th.classList.remove('sorted');
                    }
                }
            });
            
            renderTable();
        }
        
        function toggleCompare(playerId) {
            const checkbox = document.querySelector(`.player-select[data-player-id="${playerId}"]`);
            if (checkbox) {
                if (checkbox.checked) {
                    selectedForComparison.add(playerId);
                } else {
                    selectedForComparison.delete(playerId);
                }
            }
        }

        function setActiveButton(button) {
            document.querySelectorAll('.control-button').forEach(btn => btn.classList.remove('active'));
            if (button) button.classList.add('active');
        }

        function showAllPlayers(button) {
            // Update active button styling
            document.querySelectorAll('.control-button').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            // Reset active filter name
            activeQuickFilterName = null;
            
            // Reset all filters
            document.getElementById('searchName').value = '';
            document.getElementById('positionFilter').value = '';
            document.getElementById('teamFilter').value = '';
            document.getElementById('priceRange').value = '';
            document.getElementById('minPoints').value = '';
            document.getElementById('xDiffFilter').value = '';
            document.getElementById('showEntries').value = 'all';
            
            // Show all players
            const data = allPlayersData[currentDataSource];
            if (!data || !data.processedPlayers) return;
            
            displayedData = data.processedPlayers;
            sortTable(2, 'desc'); // Sort by Draft Score descending
            renderTable();
        }
        
        function quickFilter(button, filterName) {
            // Update active button styling
            document.querySelectorAll('.control-button').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            
            // Update active filter name
            activeQuickFilterName = filterName;
            
            // Reset other filters
            document.getElementById('searchName').value = '';
            document.getElementById('positionFilter').value = '';
            document.getElementById('teamFilter').value = '';
            document.getElementById('priceRange').value = '';
            document.getElementById('minPoints').value = '';
            document.getElementById('xDiffFilter').value = '';
            document.getElementById('showEntries').value = 'all';
            
            const data = allPlayersData[currentDataSource];
            if (!data || !data.processedPlayers) return;

            switch(filterName) {
                case 'set_pieces':
                    displayedData = data.processedPlayers.filter(p => p.takes_penalties || p.takes_corners || p.takes_free_kicks);
                    sortTable(2, 'desc'); // Sort by Draft Score descending
                    break;
                case 'attacking_defenders':
                    displayedData = data.processedPlayers.filter(p => p.position_name === 'DEF' && p.minutes > 300);
                    sortTable(2, 'desc'); // Sort by Draft Score descending
                    break;
                case 'high_ownership':
                    displayedData = data.processedPlayers.filter(p => parseFloat(p.selected_by_percent) >= 10);
                    sortTable(8, 'desc'); // Sort by selected_by_percent descending
                    break;
                case 'overperformers':
                    displayedData = data.processedPlayers.filter(p => p.minutes > 300 && p.xDiff > 2.5);
                    sortTable(2, 'desc'); // Sort by Draft Score descending
                    break;
                case 'differentials':
                    displayedData = data.processedPlayers.filter(p => parseFloat(p.selected_by_percent) < 5);
                    sortTable(2, 'desc'); // Sort by Draft Score descending
                    break;
                case 'newcomers':
                    displayedData = data.processedPlayers.filter(p => p.minutes === 0);
                    sortTable(2, 'desc'); // Sort by Draft Score descending
                    break;
                default:
                    displayedData = data.processedPlayers; // No filter applied
                    break;
            }
            
            renderTable();
        }

        function exportToCsv() {
            const data = allPlayersData[currentDataSource];
            if (!data || !data.processedPlayers) return;

            const headers = ['Rank','Player','Draft Score','Team','Position','Price','Points','PPG','Selected %','G+A','xG+xA','Minutes','xDiff','ICT','Bonus','Clean Sheets','Penalties','Corners','Free Kicks','Insights','News'];
            let csvContent = headers.join(',') + '\n';
            data.processedPlayers.forEach((p, i) => {
                const insightsText = generateVerbalInsights(p).replace(/<li>/g, '').replace(/<\/li>/g, ', ').replace(/<ul class="insights-list">/g, '').replace(/<\/ul>/g, '');
                const row = [
                    i + 1,
                    p.web_name.replace(/,/g, ''),
                    p.draft_score.toFixed(1),
                    p.team_name,
                    p.position_name,
                    p.now_cost,
                    p.total_points,
                    p.points_per_game,
                    p.selected_by_percent,
                    (p.goals_scored || 0) + (p.assists || 0),
                    p.expected_goal_involvements,
                    p.minutes,
                    p.xDiff.toFixed(2),
                    p.ict_index,
                    p.bonus,
                    p.clean_sheets,
                    p.takes_penalties ? 'Yes' : 'No',
                    p.takes_corners ? 'Yes' : 'No',
                    p.takes_free_kicks ? 'Yes' : 'No',
                    `"${insightsText}"`,
                    `"${p.news || ''}"`
                ];
                csvContent += row.join(',') + '\n';
            });
            const blob = new Blob([`\uFEFF${csvContent}`], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            link.setAttribute("href", URL.createObjectURL(blob));
            link.setAttribute("download", "fpl_draft_data.csv");
            link.click();
        }
        
        function compareSelectedPlayers() {
            if (selectedForComparison.size < 2) {
                alert('יש לבחור לפחות שני שחקנים להשוואה.');
                return;
            }
            const playersToCompare = allPlayersData[currentDataSource].processedPlayers.filter(p => selectedForComparison.has(p.id));
            const modal = document.getElementById('compareModal');
            const table = document.getElementById('compareTable');
            table.innerHTML = '';

            const headers = ['Metric', ...playersToCompare.map(p => p.web_name)];
            table.innerHTML = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>`;
            
            const metrics = [
                {key: 'position_name', label: 'עמדה', type: 'string'},
                {key: 'draft_score', label: 'ציון דראפט', type: 'number'},
                {key: 'now_cost', label: 'מחיר', type: 'number', reverse: true},
                {key: 'total_points', label: 'סה"כ נקודות', type: 'number'},
                {key: 'xGI_per90', label: 'xGI/90', type: 'number'},
                {key: 'xGC_per90', label: 'xGC/90', type: 'number', reverse: true},
                {key: 'xDiff', label: 'xDiff', type: 'number'},
                {key: 'ict_per_90', label: 'ICT/90', type: 'number'},
                {key: 'takes_penalties', label: 'בועט פנדלים', type: 'boolean'},
                {key: 'takes_corners', label: 'מרים קרנות', type: 'boolean'},
                {key: 'takes_free_kicks', label: 'בועט חופשיות', type: 'boolean'},
                {key: 'news', label: 'חדשות', type: 'string'}
            ];

            let bodyHtml = '<tbody>';
            metrics.forEach(metric => {
                bodyHtml += `<tr><td><strong>${metric.label}</strong></td>`;
                const metricValues = playersToCompare.map(p => p[metric.key]).filter(v => typeof v === 'number');
                const min = Math.min(...metricValues);
                const max = Math.max(...metricValues);

                playersToCompare.forEach(p => {
                    const value = p[metric.key];
                    let displayValue = value;
                    let colorClass = '';
                    if (metric.type === 'string') {
                        if (metric.key === 'news' && value) {
                            displayValue = `<span title="${value}">${value.substring(0, 15)}...</span>`;
                        } else {
                            displayValue = value || '-';
                        }
                    }
                    else if (metric.type === 'boolean') {
                        displayValue = value ? '✔' : '❌';
                        colorClass = value ? 'value-good' : '';
                    } else if (typeof value === 'number') {
                        displayValue = value.toFixed(2);
                        colorClass = getColorClass(value, min, max, !!metric.reverse);
                    } else {
                        displayValue = value || '-';
                    }
                    bodyHtml += `<td class="${colorClass}">${displayValue}</td>`;
                });
                bodyHtml += '</tr>';
            });
            bodyHtml += '</tbody>';
            table.innerHTML += bodyHtml;

            modal.style.display = 'block';
        }

        function getColorClass(value, min, max, reverse = false) {
            if (typeof value !== 'number' || min === max) return '';
            const normalized = (value - min) / (max - min);
            const effNorm = reverse ? 1 - normalized : normalized;
            if (effNorm > 0.95) return 'value-best';
            if (effNorm > 0.65) return 'value-good';
            if (effNorm > 0.35) return 'value-mid';
            if (effNorm > 0.05) return 'value-bad';
            return 'value-worst';
        }

        function closeModal() {
            document.getElementById('compareModal').style.display = 'none';
        }

    </script>
</body>
</html>
